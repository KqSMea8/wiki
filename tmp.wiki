cwbuy  qif_cgs
hello1234

1. scdf 部署应用时，可以使用的 runtime platform

2. scdf 的价值，随便两条


jvm opts: -Dspring.config.location=/Users/chenliu/demos/scdf/spring-cloud-dataflow-server-yarn/spring-cloud-dataflow-server-yarn-dist/target/spring-cloud-dataflow-server-yarn-1.2.0.BUILD-SNAPSHOT/config//servers.yml 

-Ddeployer.yarn.app.appmaster.path=/Users/chenliu/demos/scdf/spring-cloud-dataflow-server-yarn/spring-cloud-dataflow-server-yarn-dist/target/spring-cloud-dataflow-server-yarn-1.2.0.BUILD-SNAPSHOT/lib

-Ddeployer.yarn.app.container.path=/Users/chenliu/demos/scdf/spring-cloud-dataflow-server-yarn/spring-cloud-dataflow-server-yarn-dist/target/spring-cloud-dataflow-server-yarn-1.2.0.BUILD-SNAPSHOT/lib 

-Ddeployer.yarn.app.config.path=/Users/chenliu/demos/scdf/spring-cloud-dataflow-server-yarn/spring-cloud-dataflow-server-yarn-dist/target/spring-cloud-dataflow-server-yarn-1.2.0.BUILD-SNAPSHOT/config/



echo "------------------------------------"
echo "jvmcmd: ${JAVA_CMD}"
echo "jvm opts: ${JVM_OPTS[@]}"
echo "param: $@ "
echo "------------------------------------"




java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n -jar app.jar

YarnConfigBuilder shared: org.springframework.yarn.config.annotation.builders.YarnConfigBuilder@459cfcca



====== 源码预读提示 ======
SpringYarnConfigBuilder, log告知你的 yarn 配置

AbstractDeployerStateMachine 会根据 state 变化，来调用YarnCloudAppService 服务去和 yarn 集群交互
点击 deploy 之后，第一步是 pushApplication, 将应用 push 到 hdfs

DefaultYarnCloudAppService 是 YarnCloudAppService 的实现。

SpringYarnConfigs 存储 yarn 相关的配置:  yarnClient, yarnAM, yarnContainer, configuration, localizer, env.






1. Autoscalers 是否移出 api-server 模块
2. normandyId 信息不要耦合到instance中，可以放到 normandyAdapator 模块
3. event 保存快照，immutable,不能更新 
4. 按机房扩容，不需要每个机房调用一次，可以批量调用？（传入 list）
5. 扩容时，是否要检查应用正在发布，还是直接提交扩容单（让扩容单自己检查应用的发布情况）
6. 诺曼底工单结束发消息，若诺曼底不能发，就用 adaptor 来轮训，然后再发出消息
7. TMQ 替代 deletionTime，tmq 可以半小时后发出消息。







container刚创建：
deletionTime: null
CreationScheduled:N
Initialized:N
Running:N
DestructionScheduled:N

controller:
1. invoke scale out (deletionTime==null && CreateScheduled == N)
2. update container api:
    deletionTime: null
    CreationScheduled:Y
    Initialized:UNK
    Running:N
    DestructionScheduled:N
    ip: null

1. callback(message):
    1. containerId  
    if(ip==null),set Container.init=N,  Container.CreationScheduled: N 
    else  set container.ip
    check ais interface for container init, running
      if(init==Y) set Container.init = Y
      if(init==N) set Container.init=N,  Container.CreationScheduled: N 
        3.set Container.running=runing
        status:  
        deletionTime: null
        CreationScheduled:Y
        Initialized:Y
        Running:N/Y
        DestructionScheduled:N

----------------------------------------------------
container delete：
deletionTime:  30 min later
CreationScheduled:N/Y
Initialized:N/Y
Running:N/Y
DestructionScheduled:N
ip:N/Y

controller:
1. invoke scale in  (deleteionTime != null && DestruS = N )
    if(ip==null)  delete container 
    else 
        invoke ais interface  to container termination
        set container.DestructionSchduled=Y  container.Init=UNK
        
2. callback(message):
    1. containerId
    2. check ais interfiace for container init, running 
     if(init==Y) set container.Init=Y,  DestrunctionScheduler=N
     if(init==N) invoke apiserver to delete container
     if(running=y) set container.Running=Y
        
        
        
        
1. status_replicas :  所有 container， 不论  condition
2. status_runnning_replicas:  只有 running condition 的 container
3. autoscaler 中的 current_replicas 是 running 的 replica
4. autoscaler 中的 desired_replicas 是当前计算值，可能不符合 scale 规则，但是会记录。 所以这个值和rs 中的 desired 值可能不同。


